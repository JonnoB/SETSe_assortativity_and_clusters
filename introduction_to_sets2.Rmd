---
title: "Untitled"
author: "Jonathan Bourne"
date: "09/03/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---


#Set up
```{r Setup}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "stringr", "xtable", "rlang", "latex2exp", "yardstick", "minpack.lm", "ggraph", "patchwork", "rsample", "VGAM", "class", "mclust", "R.matlab")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

select <- dplyr::select
arrange <- dplyr::arrange
map <- purrr::map
sapply(packages, library, character.only = TRUE)

library(NetworkSpringEmbedding)

#Set up file system to read the correct folders this switches between aws and windows mode

#basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Sets Paper 1" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
PLwd <- "/home/jonno/setse_1_data"
CodeFolder <- "/home/jonno/SETSe_assortativity_and_clusters"
SubcodeFolder <- file.path(CodeFolder, "sub_code")

#Load some other useful functions
list.files("/home/jonno/Useful_PhD__R_Functions", pattern = ".R", full.names = T) %>%
  walk(~source(.x))


```

#Peels quintet

This section re-creates the networks used in Peel et al

```{r}

source(file = file.path(SubcodeFolder, "prepare_peels_quintet_data.R"))

 (plot_list[[1]] | plot_list[[2]] | plot_list[[3]] )/
     (plot_list[[4]]| plot_list[[5]]) +
   plot_annotation(
  title = "The Peels quintet of assortativty identical graphs",
#  subtitle = 'The graphs can be separated using SETSe'
)
ggsave(file.path(FiguresFolder,  "Peels_quintet.pdf"))

rm(plot_list)
 
```
##Peel Strain



```{r}
#requires the "quintet" and "class_data_df" data frames
source(file = file.path(SubcodeFolder, "process_peel_strain.R"))
#the basic version used the original data

peel_strain_sum %>%
  filter(k==0) %>%
  ggplot(aes(x = tension, y = elevation, colour = graph_type)) + geom_point(alpha = 0.8) +
  labs(title = "Separating Peel's quintet using embedded height and strain",
       x = "Mean edge strain",
       y = "Mean node height of class A",
       colour = "graph type")
  ggsave(file.path(FiguresFolder, "Seperating_Peels_quintet.pdf"))
#This demonstrates that the algorithm is topologically sensitive.
#Multiclass groups may be seperable using the 1 vs all method common in multiclass logitic regression, then seperating in a dimensional space equivalent to 2*(number of classes -1), that is beyond the scope of the paper.

```

##Peel knn

This tests the accuracy of the classifier created by a knn and a multinomial logistic regression.
It shows that strain and elevation can accurately classify the graph types

accuract of the knn is about 83% and 84%. N.B the old data was higher (95% and 97%), but group B had a massive strain spread which was probably an error.%
```{r}
#This needs to use some save files becuase it takes ages
source(file = file.path(SubcodeFolder, "model_basic_peels.R"))

nearest_k_results %>%
  ggplot(aes(x = k, y = accuracy )) + 
  geom_line() +
  labs(title = "The mean accuracy for 100 repeats of 10 fold cross validation for knn classifier", 
       y = "mean accuracy",
       x ="nearest neighbours")
#this file path is for casa presentation. delete after
ggsave(file.path(FiguresFolder, "knn_accuracy.pdf"))


#get mean accuracy
mean(boot_res$accuracy)

#plot distribution of accuracy
boot_res %>%
  ggplot(aes(x  = accuracy )) + 
  geom_density()

```

##Variable k
If the strength of relationship within and between groups varies then we findd that SETSe can distinguish between topologically identical networks that differ only in the strength of relationship.
```{r}


peel_strain_sum %>%
  ggplot(., aes( x= tension, y = elevation, colour = as.factor(k))) + geom_point(alpha = 0.5) +
  facet_wrap(~graph_type, scales = "free_y") +
  labs(title = "The effect of different relationship strengths within and between groups on \ntension and elevation",
       colour = "relationship"
       )
ggsave(file.path(FiguresFolder, "strength_effect.pdf"))

peel_strain_sum %>%
  filter(
  #  k == 1| k==2| k==3 |k ==0
    #    graph_id ==1,
    #    graph_type == "E",
    #k!=0
  ) %>%
  ggplot(., aes( x= tension, y = elevation, colour = as.factor(k))) + geom_point(alpha = 0.5) +
  facet_wrap(~graph_type, scales = "free_y")


```


#n-dimensional strain

C relates to A and B like A and B relate to each other. C relates to itself, like B relates to itself

```{r}
C2B <- quintet %>%
  filter(class_1 != class_2) %>%
  mutate_at(., .vars = vars(sub_class_1:class_2), .funs = ~str_replace(., "A", "C"))

C2A <- quintet %>%
  filter(class_1 != class_2) %>%
  mutate_at(., .vars = vars(sub_class_1:class_2), .funs = ~str_replace(., "B", "C"))

C2C <-  quintet %>%
  filter(class_1 =="B", class_2 == "B") %>%
  mutate_at(., .vars = vars(sub_class_1:class_2), .funs = ~str_replace(., "B", "C"))

quintet_3d <- bind_rows(quintet, C2B, C2A, C2C)


class_data_df_3d <- expand.grid(class = c("A", "B", "C"), sub = 1:2) %>%
  as_tibble() %>%
  mutate(sub_class = paste(class, sub, sep = "_"),
         size = 10 #replace with a vector if group sizes uneevn
  )

set.seed(1235)
quintet_g_list <- LETTERS[1:5] %>%
  map(~create_assortivity_graph_from_subgroups(class_data_df_3d, quintet_3d %>% rename(edges = .x), 10) %>%
        set.edge.attribute(., "type", value = .x) %>%
        set.graph.attribute(., "type", value = .x)
      
  )

#Assortativity is not the same but who cares jsut use it anyway, there are two paires
1:5 %>% map_dbl(~{
  assortativity_nominal( quintet_g_list[[.x]], types = as.factor(vertex_attr( quintet_g_list[[.x]], "class")))
  
})



plot_list2 <- 1:5 %>%
  map(~{ggraph(quintet_g_list[[.x]]) +
      geom_edge_fan()+
      geom_node_point(aes(fill= class, shape = grepl("1", sub_class)), size=3) +
      scale_shape_manual(values=c(21, 24, 23)) +
      guides(fill = "none", shape = "none") +
      labs(title = paste("Type", LETTERS[.x]))})

#red is A green is B, blue is C
#triangle means subclass 1

 (plot_list2[[1]] | plot_list2[[2]] | plot_list2[[3]] )/
     (plot_list2[[4]]| plot_list2[[5]]) 



if(file.exists( file.path(PLwd, "setse_3d.rds"))){
 setse_3d<- readRDS( file.path(PLwd, "setse_3d.rds"))
} else {
source(file = file.path(SubcodeFolder, "process_peel_strain_3d.R"))
saveRDS(setse_3d, file.path(PLwd, "setse_3d.rds"))
}

  setse_3d %>%
  ggplot(aes(x = tension, y = elevation, colour = graph_type)) + geom_point()

peel_strain_sum <- list.files(file.path(PLwd, "peel_strain_files"), full.names= T) %>% 
  map_df(~{
    setse_complete <- readRDS(.x)

    Out  <-setse_complete$graphsummary %>%
      mutate(elevation = mean(sqrt(2*(setse_complete$node_embeddings$elevation^2))))
    return(Out)
  })

test <-peel_strain_sum %>% mutate(type = "binary") %>%
  filter(k==0) %>%
  bind_rows(setse_3d %>% mutate(type = "three classes"))


test %>%
  ggplot(aes(x = tension, y = elevation, colour = graph_type)) + geom_point()+
  facet_wrap(~type) + geom_point(alpha = 0.8) +
  labs(title = "Separating Peel's quintet using embedded height and tension for binary and 3 class cases",
       x = "Mean edge tension",
       y = "Mean node height of class A",
       colour = "graph type")
ggsave(file.path(FiguresFolder, "Seperating_Peels_quintet.pdf"))
```

#Facebook data

In this section I analyse the facebook 100 dataset. I got this from https://archive.org/details/oxford-2005-facebook-matrix

```{r}


#convert the facebook .mat files to igraph format and save as rds
#this is commented out as it takes a long time and checking to see if the files are generated has not been done.
#source(file = file.path(SubcodeFolder, "convert_facebook_files.R"))

uni_files <-list.files("/home/jonno/setse_1_data/facebook100/facebook100_igraph", full.names = T)


#Create the biconnected data for the graphs with the time it takes to calculate.
source(file = file.path(SubcodeFolder, "facebook_biconnected.R"))


file_paths <-list.files("/home/jonno/setse_1_data/facebook100/facebook100_biconnected", full.names = T)
biconnected_data <- 1:length(file_paths) %>%
  map_df(~{
    
    print(file_paths[.x])
    test <-readRDS(file_paths[.x])
    
    component_size <- (test$components) %>% map_dbl(length)
    
    tibble(
      file_name =  basename(uni_files[.x]) %>% str_remove(., ".rds"),
      total = test$no, 
      time = test$time,
      max_size = max(component_size),
      min = min(component_size),
      mean_size = mean(component_size),
      median_size = median(component_size),
      component_over_two = sum(component_size>2))
    
  })


test2 <- left_join(uni_stats, biconnected_data) %>% as_tibble() %>%
  mutate(max_size_ratio = max_size/nodes) %>%
  select(uni_name:edges, total:max_size_ratio, density) %>%
  select(uni_name:nodes, max_size, max_size_ratio, everything()) %>%
  mutate(time_node = time/nodes)

test2 %>%
ggplot(aes(x =nodes, y = time)) + geom_point()

#This data frame shows that all uni's have a connected component of over 99%
#the smaller components can be disgarded
source(file = file.path(SubcodeFolder, "create_facebook_uni_stats.R"))



#This creates year embeddings for all the facebook data. 
#It is commented out as the code is does not check if the file has been made
source(file = file.path(SubcodeFolder, "facebook_embeddings_year.R"))

file_paths <- list.files("/home/jonno/setse_1_data/facebook_embeddings/facebook_year", full.names = T)

test <- 1:length(file_paths) %>%
  map_df(~{
    
    file_name <- file_paths[.x]
    
    test <- readRDS(file_name)
    
    elevation_data <-test$embeddings_data$node_embeddings %>%
      summarise(mean_abs_elev = mean(abs(elevation)),
                mean_pos_elev = mean(ifelse(elevation>0, elevation, NA),na.rm = T),
                median_abs_elev = median(abs(elevation)),
                median_pos_elev = median(ifelse(elevation>0, elevation, NA),na.rm = T),
                euc_elev = sqrt(sum(elevation^2)),
                static_force = sum(abs(static_force)),
                students = n())
    
    strain_tension <- test$embeddings_data$edge_embeddings %>%
      summarise(mean_tension = mean(tension),
                mean_strain = mean(strain),
                median_tension = median(tension),
                median_strain = median(strain),
                euc_tension = sqrt(sum(tension^2)),
                edges = n())
    
    Out <- bind_cols(elevation_data, strain_tension) %>%
      mutate(file_ext = basename(file_name),
             uni_name = file_ext %>% str_remove(., ".rds") %>% str_remove(., "[0-9]+"),
             data_id = file_ext %>% str_remove(., ".rds") %>% str_remove(., "[ a-zA-Z]+") %>% str_remove(., " ")) %>%
      select(uni_name, data_id, file_ext, everything())
    
  })


test %>% 
ggplot(aes(x = (euc_tension)/edges, y = euc_elev/students, color = students))+ geom_point()+
  scale_colour_viridis_c()

#I will use dorms over 0.5% of the total known university populations
#I will use years with over 1% of the population the rest will be reset to the mean of the students to not exert force

#In the one vs all use the height of the node when it is postive force and not when it isn't
#This is useful when you want to look at the distribution of the students.

#alternative use the euclidean distance of the mean of all positive force for the uni as a whole.
#This can be combined with the euclidean distance of the mean tension for a two dimensional projection

uni_stats %>%
  arrange(nodes) %>%
  pull(uni_name)

test2 <- test %>% transpose()

#simmons has more concentrated tension and mean distribution that Caltech
#Caltech has a higher elevation and tension per yeat
test2$node_detail %>% bind_rows()  %>%
  ggplot(aes(x = mean_tension, y = elevation, colour = year)) + 
  geom_point(alpha = 0.5) + facet_wrap(~uni)+
  scale_color_viridis_c()+
  labs(title = "Each student student at Caltech and Simmons projected into elevation
       and mean node tension, colour is year started at uni",
       x = "mean tension of all edges connected to node",
       y = "node elevation")

test2$node_detail %>% bind_rows()  %>%
  filter(as.factor(year) %in% factor(c(2004, 2005, 2006,2007, 2008, 2009))) %>%
  ggplot(aes(x = mean_tension, y = elevation, colour = uni)) + 
  geom_point(alpha = 0.5) + facet_wrap(~as.factor(year)) 

test2$node_detail %>% bind_rows()  %>%
  ggplot(aes(x = (mean_tension))) + geom_density()+ facet_wrap(~uni)

test2$node_detail %>% bind_rows() %>%
  ggplot(aes(x = factor(uni), y = log10(mean_tension))) + 
  geom_boxplot()


test3 <- test2$embeddings_data %>%
  transpose() %>%{.$network_dynamics} 

bind_rows(test3[[1]] %>% mutate(uni ="Caltech"),
          test3[[2]] %>% mutate(uni ="Simmons")) %>%
  ggplot(aes(x = Iter, y = log10(static_force), colour = uni)) + geom_line()

  uni_pattern <- grep("Simmons",uni_files )

test_stan$network_dynamics %>%
#  filter(Iter< 1500) %>%
  ggplot(aes(x = Iter, y = log10(static_force))) +
  geom_line()

g <- readRDS(uni_files[uni_pattern]) %>% #load file
  remove_small_components() %>% #remove unconnected components
  prepare_SETSe_binary(., k = 1000, force_var = "dorm", positive_value = 167, distance = 1 ) #prepare for projection


test2 <- readRDS(uni_files[uni_pattern]) %>%
 prepare_SETSe_binary(., k = 1000, force_var = "dorm", positive_value = 167, distance = 100000 ) %>%
   auto_SETSe2(., tstep = 0.1, verbose = TRUE)

test2$network_dynamics %>%
 # filter(Iter< 1500) %>%
  ggplot(aes(x = Iter, y = log10(static_force))) +
  geom_line()


  Prep <- SETSe_data_prep2(g = g, 
                          force = force, 
                          distance = distance, 
                          mass = mass, 
                          edge_name = edge_name,
                          k = k,
                          sparse = T)
  



 embeddings_data2 <- auto_SETSe2(g, tstep = 0.1, verbose = TRUE, sparse = T, sample = 100)
 embeddings_data <- auto_SETSe(g, tstep = 0.1, verbose = TRUE, sparse = T, sample = 100)

```


#The position of individual nodes 

This chunk shows that individual nodes naturally cluster by elevation with thier own sub groups sometimes the tension is also needed. I am not sure how to extract this without using a model though
```{r}

target_graphs <- tibble(file_path = list.files(file.path(PLwd, "peel_strain_files"))) %>%
  separate(
    col = file_path,
    into = c("drop1", "drop2", "graph_ref", "drop3", "k"),
    remove = FALSE,
    convert = TRUE,
    sep = "_"
  ) %>%
  mutate(k = k  %>% str_remove(., ".rds") %>%  as.integer) %>%
  select(-contains("drop")) %>%
  arrange(graph_ref)

target_graphs <- target_graphs %>%
filter(
  #graph_ref %in% c((1:35)*100),
  k ==0
  )

1:nrow(target_graphs)
#seq(from = 100, to = 500, by = 100) 
test <- 1:nrow(target_graphs)  %>% map(~{

  graph_id_choice <- .x
k_choice <- 0

file_path <-  target_graphs %>%
  filter(graph_ref ==graph_id_choice,
         k ==k_choice ) %>% pull(file_path) %>%
  file.path(PLwd,  "peel_strain_files",.  )
embeddings_data <- readRDS(file_path)

g_df<-as_data_frame(multi_quintet[[graph_id_choice]], what = "both")

edge_data <- embeddings_data$edge_embeddings  %>%
  separate(., col= edge_name, into = c("from", "to"),sep = "_", remove = FALSE ) %>%
  left_join(g_df$vertices %>% rename_all(., ~paste0("from_", .)), by = c("from" = "from_node")) %>%
  left_join(g_df$vertices %>% rename_all(., ~paste0("to_", .)), by = c("to" = "to_node")) %>%
  mutate(graph_class = case_when(.x<101~ "A",
          .x <201 ~"B",
          .x <301 ~"C",
          .x <401 ~"D",
          TRUE~"E"),
         graph_id = .x,
         combo = paste(from_sub_class, to_sub_class))
node_data <- embeddings_data$node_embeddings %>%
  left_join(g_df$vertices, by = "node") %>%
  mutate(graph_class =case_when(.x<101~ "A",
          .x <201 ~"B",
          .x <301 ~"C",
          .x <401 ~"D",
          TRUE~"E"),
         graph_id = .x)

out_data <- list(edge_data = edge_data, node_data = node_data)

return(out_data)

}) %>% transpose(.) %>%
  map(~{
    reduce(., bind_rows)
    
  })



#create a data frame that uses edge summary data for each node and 
node_data2 <- bind_rows(
  test$edge_data %>%
    select(node = from, strain, tension, graph_class, graph_id),
  test$edge_data %>%
    select(node = to, strain, tension, graph_class, graph_id)
) %>%
  group_by(node, graph_class, graph_id) %>%
  summarise_all(., .funs = list(mean = mean, median = median)) %>%
  left_join(test$node_data %>% select(node, elevation, class, sub_class, graph_class, graph_id))


node_data2 %>%
  filter(graph_id %in% seq(100, 500, by = 100)) %>%
  ggplot(aes(x = tension_mean, y = elevation, colour = sub_class)) + geom_point() +
  facet_wrap(~graph_class, scales = "free_y") +
  labs(title = "The position of individual node in each graph type")


comm_df <-test$edge_data %>%
  filter(graph_class =="D")

test2 <- multi_quintet[[400]] %>% 
  set_edge_attr(., "weight", value = 1/comm_df$tension)

  test3 <-tibble(
  node = node_data2 %>% filter(graph_class =="D") %>% pull(node),
  tension = cluster_fast_greedy(test2) %>% membership(),
       nothing =  cluster_fast_greedy(test2, weights = NULL) %>% membership())

groups <- expand_grid(graph_id =  1:500,
              class = c("A", "B"))
  
 test <- 1:nrow(groups) %>%
    map_df(~{
      
      temp_df <-node_data2 %>%
        filter(graph_id ==groups$graph_id[.x],
               class == groups$class[.x])  %>%
        ungroup
               
      delete_class <- ifelse(groups$class[.x]=="A","B", "A") #The node class that should be deletex
 
      temp_g <- multi_quintet[[groups$graph_id[.x]]] 
      temp_g <- temp_g %>% delete_vertices(., v = which( vertex_attr(temp_g, "class") == delete_class) )
      
       temp_cluster <-  temp_df%>%
        select(elevation) %>%
        kmeans(., 2) 
      temp_df %>%
        mutate(clustering_kmeans = temp_cluster$cluster,
                clustering_fast_greedy = cluster_fast_greedy(
          temp_g,
          merges = T
        ) %>% as.hclust %>%
          cutree(., k = 2),
            clustering_walktrap = cluster_walktrap(
          temp_g,
          merges = T
        ) %>% as.hclust %>%
          cutree(., k = 2)#,
       # clustering_louvain = cluster_louvain( temp_g) %>% membership()
               )
    }) %>%
   mutate_at( vars(contains("clustering")), ~ifelse(class =="A", ., .+2)) %>%
   group_by(graph_class) %>%
   mutate(tension_mean = (tension_mean-min(tension_mean))/(max(tension_mean)-min(tension_mean)),
          elevation =  (elevation-min(elevation))/(max(elevation)-min(elevation))) %>%
   ungroup
  
 test %>%
    filter(graph_id %in% seq(100, 500, by = 100)) %>%
  ggplot(aes(x = tension_mean, y = elevation, colour = factor(clustering_kmeans))) + geom_point() +
  facet_wrap(~graph_class, scales = "free_y") +
   labs(title = "the position of each node in a graph coloured by kmeans groups",
        colour = "kmeans cluster")
 
 
combos_df <- expand_grid(names = test %>% select(contains("clustering")) %>% names, graph_id = unique(test$graph_id))
 
        test_ARI <-1:nrow(combos_df) %>%
          map_df(~{
            print(.x)
            temp <-test %>%
              filter(graph_id == combos_df$graph_id[.x])
            
            tibble(
              name = combos_df$names[.x],
              graph_id = combos_df$graph_id[.x],
              graph_class = unique(temp$graph_class),
              ARI = adjustedRandIndex(temp$sub_class, temp %>% pull(combos_df$names[.x]) ))
            
          })
        
        
        #The ability to cluster graphs that have communities or groups that are not defined by their linking to each other greatly outstrips everything else
        test_ARI %>%
          mutate(clustering = name %>% str_remove(., "clustering_") %>% str_replace(., "_", " ")) %>%
          ggplot(aes(x = clustering, y = ARI, fill = clustering)) + geom_boxplot() +
          facet_wrap(~graph_class) +
          labs(title = "Adjusted rand index for different clustering methods, for each graph type")

  
```

#one vs all 

This section see' what happens when you do a one vs all test with all nodes. Do they produce sub class patterns? or does some other thing occur? Does this indicate nodal influence in a graph? If so that could lead to conflict outcome prediction

This raises the question of what happens if some of the nodes alligaiances are known... This leads on to the relgious debate networks.
```{r}


1:500 %>% walk(~{

  graph_ref <- .x
  target_file <- file.path(PLwd, "peel_influence", paste0("graph_ref_", graph_ref, ".rds") )
  
  if(!file.exists(target_file)){
    print(.x)

  g_out <- multi_quintet[[graph_ref]]
  
 Out  <- one_vs_all_SETSe(multi_quintet[[graph_ref]], k_options2)  
 
 saveRDS(Out, file = target_file)
  }
})

    

test <- 1:500 %>% 
  map_df(~{
      #I need to do this for all examples
      df <- read_rds(file.path(PLwd, "peel_influence2", paste0("graph_ref_", .x, ".rds") )) 
   df %>% 
      select(contains("clustering")) %>%
          map_dbl(~{
            
            adjustedRandIndex(df$sub_class, .x)
            
          }) %>% tibble(names = names(.), values = .) %>%
      mutate(graph = .x)

})


#The algorithm is substantially worse when using a completely unsupervised approach
#but why are all the other methods exactly the same each time?
test %>% 
  mutate(graphtype = case_when(
    graph<=100 ~"A",
    graph<=200 ~"B",
    graph<=300~"C",
    graph<=400~"D",
    TRUE ~"E"
  )) %>%
 # filter(names =="clustering_walktrap") %>%
  ggplot(aes(x = names, y = values, fill = names)) +
  geom_boxplot() +
  facet_wrap(~graphtype) +
  theme(axis.text.x = element_blank()) +
  labs(title = "ARI performance of clustering techniques when no group affiliation is given")

```

#Conflict networks

This section looks at networks that experienced conflict and how the alliagieance of the network splits
all the data is from http://vlado.fmf.uni-lj.si/pub/networks/data/ucinet/UciData.htm#sampson
```{r}
files <- list.files("/home/jonno/setse_1_data/conflict_networks", full.names = T)
```


##Medici

The traditional metrics can check what would happen if we vary the strength of the different relationships
But only SETSe can vary the beligerents

This chunk shows that although the Strozzi have more power than the Albizzi, they would have lost in a congflict against the Medici, the Albizzi who although were split against and for the medici could have overpowered them if the strength of a mariage connection was no more than twice as valuable than a business connection. After that point the Albizzi lose badly.

The traditional metrics are identical for both of the conlfict types and in fact walktrap fails to separate the beligerents for large weights of marraige ties.

```{r}

source(file = file.path(SubcodeFolder, "medici_process.R"))

AlbizziandStrozzi %>%
  filter(separate_succcess) %>%
  select(1:6, ratio) %>%
  pivot_longer(cols = 2:6, names_to = "metric", values_to = "values") %>%
    filter(metric !="ARI") %>%
  ggplot(aes(x = ratio, y = values, colour = name %>% str_remove(., "clustering_") %>% str_replace(., "_", " "), group = name)) + geom_path() +
  facet_wrap(~metric) +
  labs(title = "Medici vs Oligarchs using different power metrics",
       x = "Odds ratio of business to marriage weights",
       y = "Medici factional control",
       colour = "method") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
ggsave(file.path(FiguresFolder,  "medici_factional_controll.pdf"))       


set.seed(345)
g_medici %>%
  delete_vertices(., vertex_attr(., "name")=="PUCCI" ) %>%
  ggraph(.) + 
    geom_edge_link2( width = 0.7, edge_alpha =0.5) + 
      geom_node_point( aes(colour = party, 
                           size = ifelse(name == "MEDICI"| name =="STROZZI", 6,3))) + 
    scale_size_continuous(range = c(3, 6))+
  scale_edge_colour_viridis() +
  labs(title = "The factional alligiance of the Florentine families network") +
  guides( size = "none")+
geom_node_text(aes(label = name), nudge_y = .08)
ggsave(file.path(FiguresFolder,  "Medici_partisan_network.pdf"))

#the elevation and groups plot
# medici_strozzi$groups %>%
#   filter(marriage_weight == 300, business_weight == 100) %>%
#   ggplot(aes(x = node, y = elevation, colour = factor(party),
#              size = ifelse(node == "MEDICI"| node =="STROZZI", 6,3))) + geom_point() +
#   scale_size_continuous(range = c(3, 6))+
#   guides( size = "none") + 
#   theme(axis.text.x = element_text(angle = 25, hjust = 1))+
#   labs(title = "Medici vs Strozzi a tug of war with the families of Florence",
#        x = "Family",
#        colour = "Faction")

```

##Kapferer Mine

multiplex ties can be considered strong ties and uniplex considered weak ties.

Jackson is the boss
Lotson is the shop steward

Donald and Able worked as a pair
Abraham and Benson worked as a pair


What we learn from this dataset is that the imoprtance of the difference in weighting becomes explicit in SETSe whilst it is implicit in the the traditional clustering metrics. As such the weighting can be learned through multiple observations of interactions within graph structures, this weighting can then be deployed on new observations. This is beyond the scope of this paper!

Using a weighting of from 1to1 to 100to1 we find that the meta weight edges is an important concept to consider. Abraham does not overpower Donald in the full netowrk until multi edges are worth 5 times more than uniplex edges. This is important as edges of a multiplex network are often considered equally weighted but this may not be the case, as an example regular work contact is not necessarily as valuable in conflict as regular friendly contact.

Irrespective of the relation between uni adn multi edges Benson could never overcome Abel. What's more it required a higher weighting to for Abraham to overcome Abel, it thus appears the strategically most sensible move for Abraham to accuse Donald.

This information is not possible in a normal community detection algorithm which would always break the network into identical communities. The edge weights can be changed but this assumption has to be explicity stated using SETSe wheras the assumption is implicit in the other algorithms.

```{r}

source(file = file.path(SubcodeFolder, "kapferer_process.R"))
#SETSE separates the beliggerants everytime as expected, however the other methods can only achieve this on certain parameter settings. That said they do sucessfully show that the Abraham would have beet Donald. They are much less 
Kapferer_aggregated %>%
  left_join(kapferer_separation) %>%
  filter(value == "Abraham"| value == "Benson", 
        # cluster_method == "SETSe_kmeans",
        separate_succcess,
        cluster_method != "SETSe_kmeans"
         ) %>%
  ggplot(aes(x = ratio, y = fract, colour =str_remove(cluster_method, "clustering_") %>% str_replace(., "_", " "))) + geom_line() +
  coord_cartesian(ylim = c(0,1)) +
  facet_wrap( ~combo)+
  labs(title = "Resolution of the Kapferer mine conflict on graphs of different weights",
       y = "fraction of workers who side with Abraham/Benson",
       x = "The value of multiple edges compared to a single edge",
       colour = "method")
ggsave(file.path(FiguresFolder,  "Kapferer_mine_results.pdf"))

test <-Kapferer_aggregated %>%
  group_by(combo, 
           ratio,
           cluster_method) %>%
  summarise(separation_failure = sum(is.na(value)))


spec_res <- Kapferer_embeddings_results %>%
  filter(combo  == "Abraham-Abel",
         ratio ==10)

spec_res %>%
  ggplot(aes(x = node, y = elevation, colour = SETSe_kmeans,
              size = ifelse(node == "MEDICI"| node =="STROZZI", 6,3))) + geom_point() +
  scale_size_continuous(range = c(3, 6))+
  guides( size = "none") + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1))

as_data_frame(kapferer_mine_g) %>%
  graph_from_data_frame(., directed = FALSE, vertices = spec_res ) %>%
    ggraph(.) + 
    geom_edge_link2( width = 0.7, edge_alpha =0.5) + 
    geom_node_point( aes(
      colour = SETSe_kmeans,
      size = ifelse(name == "Abraham"| name =="Donald", 6,3))
    )  +   
  scale_size_continuous(range = c(3, 6))+
    scale_edge_colour_viridis() +
    labs(title = "Kapferer mine conflict") +
    guides( size = "none")+
    geom_node_text(aes(label = name), nudge_y = .08)
  


```

##Thurman Office

A whole host of crazy happened here this is to test what I can do with it
```{r}
file_id <- grepl("thuroff", files)

emma_vs_ann <- thurman_office_function("ANN", "EMMA")
pete_vs_minna <-  thurman_office_function("PETE", "MINNA")
emma_vs_group <- thurman_office_function("EMMA", c("ANN", "AMY", "TINA", "KATY","LISA"))


test <- emma_vs_group$groups

bind_rows(emma_vs_group$summary %>% mutate(model = "emma vs group"),
          emma_vs_ann$summary %>% mutate(model = "ann vs emma"),
          pete_vs_minna$summary %>%mutate(model = "pete vs minna")
            
            ) %>%
  mutate(name = str_remove(name, "clustering_" )%>% str_replace(., "_", " ")) %>%
  ggplot(aes(x = ratio, y = fract, colour = name, group = name)) + geom_line() +
  facet_wrap(~model) +
  labs(title = "Predicted control using SETSe and traditional clustering methods", 
       x ="Odds ratio of business to personal weights",
       y = " fraction of nodes controlled") +
    theme(axis.text.x = element_text(angle = 55, hjust = 1))
ggsave(file.path(FiguresFolder,  "thurman_factional_control.pdf"))       

emma_vs_group$groups %>%
ggplot(aes(y = elevation, x = node, colour = elevation>0)) + geom_point()

emma_vs_ann$groups %>%
ggplot(aes(y = elevation, x = node)) + geom_point() +
    theme(axis.text.x = element_text(angle = 25, hjust = 1))


emma_vs_group$groups %>%
  filter(node=="PRESIDENT")

g_out %>%
ggraph(.) + 
    geom_edge_link2( width = 0.7, edge_alpha =0.5) + 
      geom_node_point( aes(
                           size = ifelse(name == "PETE"| name =="MINNA", 6,3))) + 
    scale_size_continuous(range = c(3, 6))+
  scale_edge_colour_viridis() +
  labs(title = "The factional allegiance of the Florentine families network") +
  guides( size = "none")+
geom_node_text(aes(label = name), nudge_y = .08)

```


#Sampson data
```{r}
g_dl <- load_dl_graph(files[7], directed = FALSE)


plot(g_dl[[3]])

names(g_dl)

```

#Dynamic clustering

Dynamic clustering finds the most tens edge and removes it iterateivly until the required number of group are identified

It is not a fast method and is distinct from the elevation method

```{r}

```


#Dominance
taken from http://moreno.ss.uci.edu/data.html#bison

wolves are deference in the row not dominance

```{r}
files <- list.files("/home/jonno/setse_1_data/conflict_networks", full.names = T)

dominance_files <-list.files( "/home/jonno/setse_1_data/dominance_networks", full.names = T)


dominance_files
#plot graph
file_id <- grepl("bison", dominance_files)

g_dl <- load_dl_graph(dominance_files[file_id], directed = FALSE, return_graph = TRUE) 


g_dl %>%
  ggraph(.)+
      geom_edge_fan(aes(colour = weights)) +
      geom_node_point(aes(), size=3) +
     scale_edge_colour_viridis()

file_id <- grepl("bison", dominance_files)

g_dl <- load_dl_graph(dominance_files[file_id], directed = FALSE, return_graph = TRUE) %>%
  simplify

g_mat <- load_dl_graph(dominance_files[file_id], directed = TRUE, return_graph = FALSE)

bison_dominance <- domination_function(g_dl, g_mat)

node_win_loss_df <- tibble(node = g_mat %>% pull(from), node_wins = g_mat %>% select(-from) %>% rowSums()) %>%
      left_join(tibble(node = g_mat %>% select(-from) %>% names, node_losses = g_mat %>% select(-from) %>% colSums()),
                by = "node") %>%
      mutate(node_ratio = node_wins/(node_wins + node_losses))

bison_performance <- dominance_performance(g_dl,g_mat, bison_dominance)  %>% #add in total conlicts per edge/node pair
      left_join(node_win_loss_df %>% select(winner = node, winner_node_ratio = node_ratio), by = "winner" ) %>%
      left_join(node_win_loss_df %>% select(loser = node, loser_node_ratio = node_ratio), by = "loser" ) %>%
      mutate(relative_win_ratio = winner_node_ratio/loser_node_ratio,
             naive_res = case_when(
               relative_win_ratio>=1 & win_ratio>=0.5 ~"correct",
               relative_win_ratio<=1 & win_ratio<=0.5 ~"correct",
               TRUE ~"error"
             ))

bison_performance %>%
  ggplot(aes(x = log10(winner_tension/loser_tension) , y = ratio_euc, colour = win_ratio>0.5)) + geom_point()

table(bison_performance$class2)
table(bison_performance$naive_res)

g_dl <- load_dl_graph(dominance_files[2], directed = FALSE, return_graph = TRUE) %>%
  simplify

g_mat <- load_dl_graph(dominance_files[2], directed = TRUE, return_graph = FALSE)

cattle_dominance <- domination_function(g_dl, g_mat)

cattle_performance <- dominance_performance(g_mat, cattle_dominance)

#pony
g_dl <- load_dl_graph(dominance_files[3], directed = FALSE, return_graph = TRUE) %>%
  simplify

g_mat <- load_dl_graph(dominance_files[3], directed = TRUE, return_graph = FALSE)

pony_dominance <- domination_function(g_dl, g_mat)

pony_performance <- dominance_performance(g_mat, pony_dominance)


pony_dominance %>%
  ggplot(aes(x = factor(node), y = euc)) + geom_point()
    

graph_from_data_frame(as_data_frame(g_dl), directed = FALSE, vertices = bison_dominance$node) %>%
  ggraph(.) +
      geom_edge_fan() +
      geom_node_point(aes( colour = rank1), size=3) +
   scale_colour_viridis_c(direction = -1) 



test <- dominance_xvalidation(dominance_files[1], folds = 2, seed = 10) 


#Q if A is higher than B and A and B have conflict does A generally dominate?


test <-random_removal %>%
  filter(.metric =="bal_accuracy",
         cutoff ==1) 

random_removal 
testtest %>%
  filter(.metric =="bal_accuracy")  %>%
  ggplot(aes(x = cutoff , y = .estimate)) + geom_point()+
  facet_wrap(~seed) +
  geom_vline(xintercept = 1)



random_removal %>%
  filter(.metric =="bal_accuracy",
         cutoff>0.75,
         cutoff<1.5) %>%
  group_by(cutoff) %>%
  summarise(.estimate = mean(.estimate)) %>%
  ggplot(aes(x = factor(cutoff) , y = .estimate)) + geom_boxplot()

pony_performance %>%
  ggplot(aes(x = total, y =ratio_euc, colour = class)) + 
  geom_point()


#model accuracy is maximised when the ratio of 1 is used as the cutoff.
#This is the bare minimum as they will literally pull in other directions so the accuracy should be high
seq(0,2, by = 0.05) %>%
  map_df(~{
    pony_performance %>%
      mutate( 
        truth = factor(total>0.5, levels = c(TRUE, FALSE)),
        estimate= factor(ratio_euc >= .x, levels = c(TRUE, FALSE))) %>%
      metrics(., truth = truth, estimate = estimate) %>%
      mutate(cutoff = .x)
    
  }) 


test_res%>%
  ggplot(aes(x = cutoff, y = .estimate))+ geom_point() +
  facet_wrap(~.metric)

#Q does heignt in matrix predict breeding success?


fold_test <- dominance_xvalidation(dominance_files[1], folds = 2, seed = 10) 
fold_test_perf <- fold_test$performance_df
fold_test_cutoff <- fold_test$model_analysis %>%
  filter(.metric == "accuracy") 


#test_10 
#test_2 <- fold_test_cutoff 

test <- bind_rows(test_10 %>% mutate(fold = 10),
          test_5 %>% mutate(fold = 5),
            test_2 %>% mutate(fold = 2)) %>%
  group_by(type, fold) %>%
  summarise(mean = mean(.estimate))

test %>%
  rename(estimate = .estimate) %>%
  select(fold, type, estimate) %>%
  pivot_wider( names_from = type, values_from = estimate)

fold_test_cutoff %>%
  filter(.metric == "accuracy") %>%
  ggplot(aes(x = .estimate, colour = type)) + geom_density()

fold_test_cutoff %>%
  filter(.metric == "accuracy") %>%
  ggplot(aes(x = type, y =  .estimate, colour = type)) + geom_boxplot()

test2 <- test$cutoff_analysis

test <- list.files("/home/jonno/setse_1_data/dominance/bison/repeats", 
                   full.names = T) %>%
  map(read_rds)  %>% transpose() %>%
  map(~{.x %>% bind_rows()})

test2<- test$performance_df 
test3 <- test$cutoff_analysis


test3 %>%
  group_by(fold, seed) %>%
  summarise(counts = n())

test_na <- test3 %>% filter(is.na(.estimate), .metric == "accuracy",
                            cutoff == 1)

#the density plot of the mean accuracy by repeat
test3 %>%
  filter(.metric =="accuracy",
         cutoff==1) %>%
  mutate(cutoff = factor(cutoff)) %>%
  ggplot(aes( x = .estimate)) + geom_density() +
  theme(axis.text.x = element_text(angle = 35, hjust = 1))


repeat_agg <- test3 %>%
  group_by(.metric, cutoff, seed) %>%
  summarise(mean = mean(.estimate),
            sd = sd(.estimate),
            median = median(.estimate)) %>%
  ungroup

repeat_agg  %>%
  filter(.metric =="accuracy",
       #  cutoff>0.8,
         cutoff==1) %>%
  mutate(cutoff = factor(cutoff)) %>%
  ggplot(aes(  x = mean)) + geom_density() +
  theme(axis.text.x = element_text(angle = 35, hjust = 1)) +
  labs(title = "Repeated cross validation mean accuracy",
       x = "Elevation ratio minimum",
       y = "mean accuracy for each k10 repeat")


test3 %>%
  filter(.metric =="accuracy",
         cutoff == "1") %>%
  pull(.estimate) %>% t.test(., alternative = "greater", mu = 0.5)

#bootstrap confidence
set.seed(13)
resample2 <- bootstraps(test3 %>% filter(.metric=="accuracy", cutoff ==1.1), times = 1000)
map_dbl(resample2$splits,
        function(x) {
          dat <- as.data.frame(x)$.estimate
          mean(dat>0.5, na.rm = T)
        })

test <- performance_df %>%
  filter(holdout) %>%
  select(winner, loser, class2, naive_res)

table(test$class2, test$naive_res)



```

#deference

```{r}
file_id <- grepl("wolf.dat", dominance_files)

g_dl <- load_dl_graph(dominance_files[file_id], directed = FALSE, return_graph = TRUE) %>%
  simplify

g_mat <- load_dl_graph(dominance_files[file_id], directed = TRUE, return_graph = FALSE) %>%
  pivot_longer(., cols = -from, names_to = "winner") %>%
  pivot_wider(., names_from = from, values_from = value) %>%
  rename(from = winner)

deference_dominace <- domination_function(g_dl, g_mat)

node_win_loss_df <- tibble(node = g_mat %>% pull(from), node_wins = g_mat %>% select(-from) %>% rowSums()) %>%
      left_join(tibble(node = g_mat %>% select(-from) %>% names, node_losses = g_mat %>% select(-from) %>% colSums()),
                by = "node") %>%
      mutate(node_ratio = node_wins/(node_wins + node_losses))

deference_performance <- dominance_performance(g_dl,g_mat, deference_dominace)  %>% #add in total conlicts per edge/node pair
      left_join(node_win_loss_df %>% select(winner = node, winner_node_ratio = node_ratio), by = "winner" ) %>%
      left_join(node_win_loss_df %>% select(loser = node, loser_node_ratio = node_ratio), by = "loser" ) %>%
      mutate(relative_win_ratio = winner_node_ratio/loser_node_ratio,
             naive_res = case_when(
               relative_win_ratio>=1 & win_ratio>=0.5 ~"correct",
               relative_win_ratio<=1 & win_ratio<=0.5 ~"correct",
               TRUE ~"error"
             ))

deference_performance_norm 
#deference_performance2 <- deference_performance
table(deference_performance2$class2)

table(deference_performance2$naive_res)


test_node <- dominance_list$node

test_edge <- dominance_list$edge
```

