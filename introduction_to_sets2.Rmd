---
title: "Untitled"
author: "Jonathan Bourne"
date: "09/03/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---


#Set up
```{r Setup}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "stringr", "xtable", "rlang", "latex2exp", "yardstick", "minpack.lm", "ggraph", "patchwork", "rsample", "VGAM", "class", "mclust")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

select <- dplyr::select
arrange <- dplyr::arrange
map <- purrr::map
sapply(packages, library, character.only = TRUE)

library(NetworkSpringEmbedding)

#Set up file system to read the correct folders this switches between aws and windows mode

#basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Sets Paper 1" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
PLwd <- "/home/jonno/setse_1_data"
CodeFolder <- "/home/jonno/introduction_to_sets"
SubcodeFolder <- file.path(CodeFolder, "sub_code")

#Load some other useful functions
list.files("/home/jonno/Useful_PhD__R_Functions", pattern = ".R", full.names = T) %>%
  walk(~source(.x))


```

#Peels quintet

This section re-creates the networks used in Peel et al

```{r}

source(file = file.path(SubcodeFolder, "prepare_peels_quintet_data.R"))

 (plot_list[[1]] | plot_list[[2]] | plot_list[[3]] )/
     (plot_list[[4]]| plot_list[[5]]) +
   plot_annotation(
  title = "The Peels quintet of assortativty identical graphs",
#  subtitle = 'The graphs can be separated using SETSe'
)
ggsave(file.path(FiguresFolder,  "Peels_quintet.pdf"))

rm(plot_list)
 
```
##Peel Strain

```{r}
#requires the "quintet" and "class_data_df" data frames
source(file = file.path(SubcodeFolder, "process_peel_strain.R"))
#the basic version used the original data

peel_strain_sum %>%
  filter(k==0) %>%
  ggplot(aes(x = tension, y = elevation, colour = graph_type)) + geom_point(alpha = 0.8) +
  labs(title = "Separating Peel's quintet using embedded height and strain",
       x = "Mean edge strain",
       y = "Mean node height of class A",
       colour = "graph type")
  ggsave(file.path(FiguresFolder, "Seperating_Peels_quintet.pdf"))
#This demonstrates that the algorithm is topologically sensitive.
#Multiclass groups may be seperable using the 1 vs all method common in multiclass logitic regression, then seperating in a dimensional space equivalent to 2*(number of classes -1), that is beyond the scope of the paper.

```

##Peel knn

This tests the accuracy of the classifier created by a knn and a multinomial logistic regression.
It shows that strain and elevation can accurately classify the graph types

accuract of the knn is about 83% and 84%. N.B the old data was higher (95% and 97%), but group B had a massive strain spread which was probably an error.%
```{r}
#This needs to use some save files becuase it takes ages
source(file = file.path(SubcodeFolder, "model_basic_peels.R"))

nearest_k_results %>%
  ggplot(aes(x = k, y = accuracy )) + 
  geom_line() +
  labs(title = "The mean accuracy for 100 repeats of 10 fold cross validation for knn classifier", 
       y = "mean accuracy",
       x ="nearest neighbours")
#this file path is for casa presentation. delete after
ggsave(file.path(FiguresFolder, "knn_accuracy.pdf"))


#get mean accuracy
mean(boot_res$accuracy)

#plot distribution of accuracy
boot_res %>%
  ggplot(aes(x  = accuracy )) + 
  geom_density()

```

##Variable k
If the strength of relationship within and between groups varies then we findd that SETSe can distinguish between topologically identical networks that differ only in the strength of relationship.
```{r}


peel_strain_sum %>%
  ggplot(., aes( x= tension, y = elevation, colour = as.factor(k))) + geom_point(alpha = 0.5) +
  facet_wrap(~graph_type, scales = "free_y") +
  labs(title = "The effect of different relationship strengths within and between groups on \ntension and elevation",
       colour = "relationship"
       )
ggsave(file.path(FiguresFolder, "strength_effect.pdf"))

peel_strain_sum %>%
  filter(
  #  k == 1| k==2| k==3 |k ==0
    #    graph_id ==1,
    #    graph_type == "E",
    #k!=0
  ) %>%
  ggplot(., aes( x= tension, y = elevation, colour = as.factor(k))) + geom_point(alpha = 0.5) +
  facet_wrap(~graph_type, scales = "free_y")


```

```{r}

test1<- list.files(file.path(PLwd, "peel_strain_files"), full.names= T) %>% 
  map(~{
    setse_complete <- readRDS(.x)
    Out <- list()
    graph_details <- setse_complete$graphsummary %>% select(k_group =k, graph_type, graph_id ) 
    Out$node_embeddings  <-bind_cols(setse_complete$node_embeddings, graph_details %>%
      slice(rep(1, 40)))
    Out$edge_embeddings <- bind_cols(setse_complete$edge_embeddings, graph_details%>%
      slice(rep(1, 160)))
    names(Out$edge_embeddings) <- str_remove(names(Out$edge_embeddings), pattern = regex("_\\d"))
    return(Out)
  })

test2 <- transpose(test1)$edge_embeddings %>% bind_rows() %>% mutate(full_id = paste(k_group, graph_type, graph_id))
test3 <- transpose(test1)$node_embeddings %>% bind_rows() %>% mutate(full_id = paste(k_group, graph_type, graph_id)) %>%
  group_by(full_id) %>%
  mutate(elev_pos = elevation + min(elevation)) %>%
  left_join(as_data_frame(multi_quintet[[1]], what ="vertices"))


test2 %>%
  ggplot(aes(x = (strain), colour = graph_type)) + geom_density()+
  facet_wrap(~graph_type)

test3 %>%
#  filter(graph_type =="") %>%
  ggplot(aes(x = (elev_pos),  colour = graph_type)) + geom_density()+
  facet_wrap(~sub_class)

```

#n-dimensional strain

C relates to A and B like A and B relate to each other. C relates to itself, like B relates to itself

```{r}
C2B <- quintet %>%
  filter(class_1 != class_2) %>%
  mutate_at(., .vars = vars(sub_class_1:class_2), .funs = ~str_replace(., "A", "C"))

C2A <- quintet %>%
  filter(class_1 != class_2) %>%
  mutate_at(., .vars = vars(sub_class_1:class_2), .funs = ~str_replace(., "B", "C"))

C2C <-  quintet %>%
  filter(class_1 =="B", class_2 == "B") %>%
  mutate_at(., .vars = vars(sub_class_1:class_2), .funs = ~str_replace(., "B", "C"))

quintet_3d <- bind_rows(quintet, C2B, C2A, C2C)


class_data_df_3d <- expand.grid(class = c("A", "B", "C"), sub = 1:2) %>%
  as_tibble() %>%
  mutate(sub_class = paste(class, sub, sep = "_"),
         size = 10 #replace with a vector if group sizes uneevn
  )

set.seed(1235)
quintet_g_list <- LETTERS[1:5] %>%
  map(~create_assortivity_graph_from_subgroups(class_data_df_3d, quintet_3d %>% rename(edges = .x), 10) %>%
        set.edge.attribute(., "type", value = .x) %>%
        set.graph.attribute(., "type", value = .x)
      
  )

#Assortativity is not the same but who cares jsut use it anyway, there are two paires
1:5 %>% map_dbl(~{
  assortativity_nominal( quintet_g_list[[.x]], types = as.factor(vertex_attr( quintet_g_list[[.x]], "class")))
  
})



plot_list2 <- 1:5 %>%
  map(~{ggraph(quintet_g_list[[.x]]) +
      geom_edge_fan()+
      geom_node_point(aes(fill= class, shape = grepl("1", sub_class)), size=3) +
      scale_shape_manual(values=c(21, 24, 23)) +
      guides(fill = "none", shape = "none") +
      labs(title = paste("Type", LETTERS[.x]))})

#red is A green is B, blue is C
#triangle means subclass 1

 (plot_list2[[1]] | plot_list2[[2]] | plot_list2[[3]] )/
     (plot_list2[[4]]| plot_list2[[5]]) 



if(file.exists( file.path(PLwd, "setse_3d.rds"))){
 setse_3d<- readRDS( file.path(PLwd, "setse_3d.rds"))
} else {
source(file = file.path(SubcodeFolder, "process_peel_strain_3d.R"))
saveRDS(setse_3d, file.path(PLwd, "setse_3d.rds"))
}

  setse_3d %>%
  ggplot(aes(x = tension, y = elevation, colour = graph_type)) + geom_point()

peel_strain_sum <- list.files(file.path(PLwd, "peel_strain_files"), full.names= T) %>% 
  map_df(~{
    setse_complete <- readRDS(.x)

    Out  <-setse_complete$graphsummary %>%
      mutate(elevation = mean(sqrt(2*(setse_complete$node_embeddings$elevation^2))))
    return(Out)
  })

test <-peel_strain_sum %>% mutate(type = "binary") %>%
  filter(k==0) %>%
  bind_rows(setse_3d %>% mutate(type = "three classes"))


test %>%
  ggplot(aes(x = tension, y = elevation, colour = graph_type)) + geom_point()+
  facet_wrap(~type) + geom_point(alpha = 0.8) +
  labs(title = "Separating Peel's quintet using embedded height and tension for binary and 3 class cases",
       x = "Mean edge tension",
       y = "Mean node height of class A",
       colour = "graph type")
ggsave(file.path(FiguresFolder, "Seperating_Peels_quintet.pdf"))
```


#The position of individual nodes 

This chunk shows that individual nodes naturally cluster by elevation with thier own sub groups sometimes the tension is also needed. I am not sure how to extract this without using a model though
```{r}

target_graphs <- tibble(file_path = list.files(file.path(PLwd, "peel_strain_files"))) %>%
  separate(
    col = file_path,
    into = c("drop1", "drop2", "graph_ref", "drop3", "k"),
    remove = FALSE,
    convert = TRUE,
    sep = "_"
  ) %>%
  mutate(k = k  %>% str_remove(., ".rds") %>%  as.integer) %>%
  select(-contains("drop")) %>%
  arrange(graph_ref)

target_graphs <- target_graphs %>%
filter(
  #graph_ref %in% c((1:35)*100),
  k ==0
  )

1:nrow(target_graphs)
#seq(from = 100, to = 500, by = 100) 
test <- 1:nrow(target_graphs)  %>% map(~{

  graph_id_choice <- .x
k_choice <- 0

file_path <-  target_graphs %>%
  filter(graph_ref ==graph_id_choice,
         k ==k_choice ) %>% pull(file_path) %>%
  file.path(PLwd,  "peel_strain_files",.  )
embeddings_data <- readRDS(file_path)

g_df<-as_data_frame(multi_quintet[[graph_id_choice]], what = "both")

edge_data <- embeddings_data$edge_embeddings  %>%
  separate(., col= edge_name, into = c("from", "to"),sep = "_", remove = FALSE ) %>%
  left_join(g_df$vertices %>% rename_all(., ~paste0("from_", .)), by = c("from" = "from_node")) %>%
  left_join(g_df$vertices %>% rename_all(., ~paste0("to_", .)), by = c("to" = "to_node")) %>%
  mutate(graph_class = case_when(.x<101~ "A",
          .x <201 ~"B",
          .x <301 ~"C",
          .x <401 ~"D",
          TRUE~"E"),
         graph_id = .x,
         combo = paste(from_sub_class, to_sub_class))
node_data <- embeddings_data$node_embeddings %>%
  left_join(g_df$vertices, by = "node") %>%
  mutate(graph_class =case_when(.x<101~ "A",
          .x <201 ~"B",
          .x <301 ~"C",
          .x <401 ~"D",
          TRUE~"E"),
         graph_id = .x)

out_data <- list(edge_data = edge_data, node_data = node_data)

return(out_data)

}) %>% transpose(.) %>%
  map(~{
    reduce(., bind_rows)
    
  })



#create a data frame that uses edge summary data for each node and 
node_data2 <- bind_rows(
  test$edge_data %>%
    select(node = from, strain, tension, graph_class, graph_id),
  test$edge_data %>%
    select(node = to, strain, tension, graph_class, graph_id)
) %>%
  group_by(node, graph_class, graph_id) %>%
  summarise_all(., .funs = list(mean = mean, median = median)) %>%
  left_join(test$node_data %>% select(node, elevation, class, sub_class, graph_class, graph_id))


node_data2 %>%
  filter(graph_id %in% seq(100, 500, by = 100)) %>%
  ggplot(aes(x = tension_mean, y = elevation, colour = sub_class)) + geom_point() +
  facet_wrap(~graph_class, scales = "free_y") +
  labs(title = "The position of individual node in each graph type")


comm_df <-test$edge_data %>%
  filter(graph_class =="D")

test2 <- multi_quintet[[400]] %>% 
  set_edge_attr(., "weight", value = 1/comm_df$tension)

  test3 <-tibble(
  node = node_data2 %>% filter(graph_class =="D") %>% pull(node),
  tension = cluster_fast_greedy(test2) %>% membership(),
       nothing =  cluster_fast_greedy(test2, weights = NULL) %>% membership())

groups <- expand_grid(graph_id =  1:500,
              class = c("A", "B"))
  
 test <- 1:nrow(groups) %>%
    map_df(~{
      
      temp_df <-node_data2 %>%
        filter(graph_id ==groups$graph_id[.x],
               class == groups$class[.x])  %>%
        ungroup
               
      delete_class <- ifelse(groups$class[.x]=="A","B", "A") #The node class that should be deletex
 
      temp_g <- multi_quintet[[groups$graph_id[.x]]] 
      temp_g <- temp_g %>% delete_vertices(., v = which( vertex_attr(temp_g, "class") == delete_class) )
      
       temp_cluster <-  temp_df%>%
        select(elevation) %>%
        kmeans(., 2) 
      temp_df %>%
        mutate(clustering_kmeans = temp_cluster$cluster,
                clustering_fast_greedy = cluster_fast_greedy(
          temp_g,
          merges = T
        ) %>% as.hclust %>%
          cutree(., k = 2),
            clustering_walktrap = cluster_walktrap(
          temp_g,
          merges = T
        ) %>% as.hclust %>%
          cutree(., k = 2)#,
       # clustering_louvain = cluster_louvain( temp_g) %>% membership()
               )
    }) %>%
   mutate_at( vars(contains("clustering")), ~ifelse(class =="A", ., .+2)) %>%
   group_by(graph_class) %>%
   mutate(tension_mean = (tension_mean-min(tension_mean))/(max(tension_mean)-min(tension_mean)),
          elevation =  (elevation-min(elevation))/(max(elevation)-min(elevation))) %>%
   ungroup
  
 test %>%
    filter(graph_id %in% seq(100, 500, by = 100)) %>%
  ggplot(aes(x = tension_mean, y = elevation, colour = factor(clustering_kmeans))) + geom_point() +
  facet_wrap(~graph_class, scales = "free_y") +
   labs(title = "the position of each node in a graph coloured by kmeans groups",
        colour = "kmeans cluster")
 
 
combos_df <- expand_grid(names = test %>% select(contains("clustering")) %>% names, graph_id = unique(test$graph_id))
 
        test_ARI <-1:nrow(combos_df) %>%
          map_df(~{
            print(.x)
            temp <-test %>%
              filter(graph_id == combos_df$graph_id[.x])
            
            tibble(
              name = combos_df$names[.x],
              graph_id = combos_df$graph_id[.x],
              graph_class = unique(temp$graph_class),
              ARI = adjustedRandIndex(temp$sub_class, temp %>% pull(combos_df$names[.x]) ))
            
          })
        
        
        #The ability to cluster graphs that have communities or groups that are not defined by their linking to each other greatly outstrips everything else
        test_ARI %>%
          mutate(clustering = name %>% str_remove(., "clustering_") %>% str_replace(., "_", " ")) %>%
          ggplot(aes(x = clustering, y = ARI, fill = clustering)) + geom_boxplot() +
          facet_wrap(~graph_class) +
          labs(title = "Adjusted rand index for different clustering methods, for each graph type")

  
```

#one vs all 

This section see' what happens when you do a one vs all test with all nodes. Do they produce sub class patterns? or does some other thing occur? Does this indicate nodal influence in a graph? If so that could lead to conflict outcome prediction

```{r}
 graph_ref <- 450
  g_out <- multi_quintet[[graph_ref]]
  
  graph_type <- graph_attr(g_out, "type")
  
  g_df <- as_data_frame(g_out, what = "both")
  
  edge_df <- left_join(
    g_df$edges %>% mutate(edge_name = paste(from, to, sep = "_"),
                          from = as.character(from),
                          to = as.character(to)),
    g_df$vertices %>%
      rename(from_class = class, from_sub_class = sub_class),
    by = c("from"="node")) %>%
    left_join(.,
              g_df$vertices %>%
                rename(to_class = class, to_sub_class = sub_class),
              by = c("to"="node")) %>%
    mutate(
      match_type = case_when(
        from_sub_class == to_sub_class ~ "sub",
        from_class == to_class ~ "class",
        TRUE ~ "inter"
      ),
      flow = 1,
      distance = 1,
      capacity = 1
    ) %>%
    left_join(k_options2, by = "match_type")
  
  
  
setse_params  <-expand_grid(node =1:40, k =0)
1:nrow(setse_params) %>% walk(~{
    
         g_out <-graph_from_data_frame(edge_df, directed = FALSE,  g_df$vertices %>% select(node, class, sub_class) %>%
                                  mutate(force = case_when(
                                    node == 1 ~1,
                                    node ==40~-1,
                                    TRUE~0
                                  ))) #Forces sum to 1
    
     g_out <-graph_from_data_frame(edge_df, directed = FALSE,  g_df$vertices %>% select(node, class, sub_class) %>%
                                  mutate(force = ifelse(node == setse_params$node[.x], 1, -1/39))) #Forces sum to 1
    
    save_path <- file.path(PLwd, "peel_influence", paste0("graph_ref_", graph_ref, "_k_", setse_params$k[.x], "_node_",
                                                          setse_params$node[.x], ".rds") )
if(!file.exists(save_path)){    
    setse_complete <- auto_SETSe(g_out,
                                 force = "force",
                                 flow = "flow",
                                 distance = "distance",
                                 capacity = "capacity",
                                 edge_name = "edge_name",
                                 k = paste0("k_", setse_params$k[.x]),
                                 tol = 40/10000,
                                 hyper_max = 50000,
                                 hyper_tol = 0.001,
                                 step_size = 0.1,
                                 verbose = F)
    
    setse_complete$graphsummary <- tibble(
      strain = mean(abs(setse_complete$edge_embeddings$strain)),
      elevation =  mean(sqrt(
        2 * (setse_complete$node_embeddings$elevation ^ 2)
      )),
      elevation_no_node = left_join(setse_complete$node_embeddings, g_df$vertices, by = "node") %>%
        filter(node != setse_params$node[.x]) %>%
        pull(elevation) %>% mean,
      tension = mean(abs(setse_complete$edge_embeddings$tension)),
      residual_force =  mean(abs(
        setse_complete$node_embeddings$static_force
      )),
      node = setse_params$node[.x]
    ) %>%
      mutate(graph_type = graph_type,
             graph_id = graph_ref)
    
    saveRDS(setse_complete, save_path)
    }

  })
  
  
  
  means_df <-list.files(file.path(PLwd, "peel_influence"), full.names = T) %>% map_df(~{
    
    readRDS(.x)$graphsummary
    
  }) %>%
    mutate(graph_id = as.character(graph_id),
           node = as.character(node)) %>%
  left_join(g_df$vertices) %>%
    select(node, everything())
  
  
  
  means_df %>%
  ggplot(aes(x = tension, y = elevation, colour = sub_class)) + geom_point()
  
   means_df %>%
  ggplot(aes(x = elevation)) + geom_density()
  
  g_out2 <-graph_from_data_frame(edge_df, directed = FALSE,  means_df ) 
  

    ggraph(g_out2) +
         geom_edge_link() +
      geom_node_point(aes(colour= tension), size=3) +
      guides(fill = "none")+
      scale_color_viridis_c()
    

    #get elevation and strain vector
    elev_vectors <-list.files(file.path(PLwd, "peel_influence"), full.names = T) %>% map(~{
      
      print(.x)
      data_list <- readRDS(.x)
      graph_summary <- data_list$graphsummary
      
      
      data_list$node_embeddings %>% select(node, elevation) %>% setNames(c("node",paste0("node_", graph_summary$node)))
      
    }) %>%
      reduce(left_join, by = "node")
    
    
    

    
    means_df2 <- means_df %>%
      mutate(clustering_k4 = kmeans(elev_vectors %>% select(-node) , centers = 4)$cluster %>% factor(),
             clustering_louvain = cluster_louvain( g_out2) %>% membership(),
             clustering_fast_greedy =cluster_fast_greedy(
         g_out2,
          weights = NULL,
          merges = T
        ) %>% as.hclust %>%
          cutree(., k = 4),
             clustering_walktrap = cluster_walktrap(
         g_out2,
          weights = NULL,
          merges = T
        ) %>% as.hclust %>%
          cutree(., k = 4))

        #When the system is totally unsupervised the results are slightly worse that fast greedy,louvain and walk trap.
        #If k means is set to 3 then the performance is equal to the peformance of the clustering methods which all produce 3
        #This is only from a single example though.
        means_df2 %>% select(contains("clustering")) %>%
          map_dbl(~{
            
            adjustedRandIndex(means_df2$sub_class, .x)
            
          }) %>% tibble(names = names(.), values = .)



```

#Conflict networks

This section looks at networks that experienced conflict and how the alliagieance of the network splits
all the data is from http://vlado.fmf.uni-lj.si/pub/networks/data/ucinet/UciData.htm#sampson
```{r}
files <- list.files("/home/jonno/setse_1_data/conflict_networks", full.names = T)
```


##Medici

The traditional metrics can check what would happen if we vary the strength of the different relationships
But only SETSe can vary the beligerents

This chunk shows that although the Strozzi have more power than the Albizzi, they would have lost in a congflict against the Medici, the Albizzi who although were split against and for the medici could have overpowered them if the strength of a mariage connection was no more than twice as valuable than a business connection. After that point the Albizzi lose badly.

The traditional metrics are identical for both of the conlfict types and in fact walktrap fails to separate the beligerents for large weights of marraige ties.

```{r}

source(file = file.path(SubcodeFolder, "medici_process.R"))

AlbizziandStrozzi %>%
  filter(separate_succcess) %>%
  select(1:6, ratio) %>%
  pivot_longer(cols = 2:6, names_to = "metric", values_to = "values") %>%
    filter(metric !="ARI") %>%
  ggplot(aes(x = ratio, y = values, colour = name %>% str_remove(., "clustering_") %>% str_replace(., "_", " "), group = name)) + geom_path() +
  facet_wrap(~metric) +
  labs(title = "Medici vs Oligarchs using different power metrics",
       x = "Odds ratio of business to marriage weights",
       colour = "method") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
ggsave(file.path(FiguresFolder,  "medici_factional_controll.pdf"))       


set.seed(345)
g_medici %>%
  delete_vertices(., vertex_attr(., "name")=="PUCCI" ) %>%
  ggraph(.) + 
    geom_edge_link2( width = 0.7, edge_alpha =0.5) + 
      geom_node_point( aes(colour = party, 
                           size = ifelse(name == "MEDICI"| name =="STROZZI", 6,3))) + 
    scale_size_continuous(range = c(3, 6))+
  scale_edge_colour_viridis() +
  labs(title = "Node elevation and edge tension for the Zachery karate club") +
  guides( size = "none")+
geom_node_text(aes(label = name), nudge_y = .08)
ggsave(file.path(FiguresFolder,  "Medici_partisan_network.pdf"))

#the elevation and groups plot
# medici_strozzi$groups %>%
#   filter(marriage_weight == 300, business_weight == 100) %>%
#   ggplot(aes(x = node, y = elevation, colour = factor(party),
#              size = ifelse(node == "MEDICI"| node =="STROZZI", 6,3))) + geom_point() +
#   scale_size_continuous(range = c(3, 6))+
#   guides( size = "none") + 
#   theme(axis.text.x = element_text(angle = 25, hjust = 1))+
#   labs(title = "Medici vs Strozzi a tug of war with the families of Florence",
#        x = "Family",
#        colour = "Faction")

```

#Kapferer Mine

multiplex ties can be considered strong ties and uniplex considered weak ties.

Jackson is the boss
Lotson is the shop steward

Donald and Able worked as a pair
Abraham and Benson worked as a pair


What we learn from this dataset is that the imoprtance of the difference in weighting becomes explicit in SETSe whilst it is implicit in the the traditional clustering metrics. As such the weighting can be learned through multiple observations of interactions within graph structures, this weighting can then be deployed on new observations. This is beyond the scope of this paper!

Using a weighting of from 1to1 to 100to1 we find that the meta weight edges is an important concept to consider. Abraham does not overpower Donald in the full netowrk until multi edges are worth 5 times more than uniplex edges. This is important as edges of a multiplex network are often considered equally weighted but this may not be the case, as an example regular work contact is not necessarily as valuable in conflict as regular friendly contact.

Irrespective of the relation between uni adn multi edges Benson could never overcome Abel. What's more it required a higher weighting to for Abraham to overcome Abel, it thus appears the strategically most sensible move for Abraham to accuse Donald.

This information is not possible in a normal community detection algorithm which would always break the network into identical communities. The edge weights can be changed but this assumption has to be explicity stated using SETSe wheras the assumption is implicit in the other algorithms.

```{r}

source(file = file.path(SubcodeFolder, "kapferer_process.R"))
#SETSE separates the beliggerants everytime as expected, however the other methods can only achieve this on certain parameter settings. That said they do sucessfully show that the Abraham would have beet Donald. They are much less 
Kapferer_aggregated %>%
  left_join(kapferer_separation) %>%
  filter(value == "Abraham"| value == "Benson", 
        # cluster_method == "SETSe_kmeans",
        separate_succcess,
        cluster_method != "SETSe_kmeans"
         ) %>%
  ggplot(aes(x = ratio, y = fract, colour =str_remove(cluster_method, "clustering_") %>% str_replace(., "_", " "))) + geom_line() +
  coord_cartesian(ylim = c(0,1)) +
  facet_wrap( ~combo)+
  labs(title = "Resolution of the Kapferer mine conflict on graphs of different weights",
       y = "fraction of workers who side with Abraham/Benson",
       x = "The value of multiple edges compared to a single edge",
       colour = "method")
ggsave(file.path(FiguresFolder,  "Kapferer_mine_results.pdf"))

test <-Kapferer_aggregated %>%
  group_by(combo, 
           ratio,
           cluster_method) %>%
  summarise(separation_failure = sum(is.na(value)))


spec_res <- Kapferer_embeddings_results %>%
  filter(combo  == "Abraham-Abel",
         ratio ==10)

spec_res %>%
  ggplot(aes(x = node, y = elevation, colour = SETSe_kmeans,
              size = ifelse(node == "MEDICI"| node =="STROZZI", 6,3))) + geom_point() +
  scale_size_continuous(range = c(3, 6))+
  guides( size = "none") + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1))

as_data_frame(kapferer_mine_g) %>%
  graph_from_data_frame(., directed = FALSE, vertices = spec_res ) %>%
    ggraph(.) + 
    geom_edge_link2( width = 0.7, edge_alpha =0.5) + 
    geom_node_point( aes(
      colour = SETSe_kmeans,
      size = ifelse(name == "Abraham"| name =="Donald", 6,3))
    )  +   
  scale_size_continuous(range = c(3, 6))+
    scale_edge_colour_viridis() +
    labs(title = "Kapferer mine conflict") +
    guides( size = "none")+
    geom_node_text(aes(label = name), nudge_y = .08)
  


```

#Dynamic clustering

Dynamic clustering finds the most tens edge and removes it iterateivly until the required number of group are identified

It is not a fast method and is distinct from the elevation method

```{r}

```


